---
// This renders an island of "server-rendered" content for a given route
// It will allow the router to do fine-grained updates of a given page's content
// And will have behaviours of whether a frame should come or go on a given route
// It will also serialize the data for a given frame into the frame
// To allow for server-side persistence and hydration

import { dehydrateStores } from './src/stores/hydration';
import { hydrateServerStore } from './src/stores/hydration';
import type { Store } from './src/stores/store';

export interface Props {
  id: string
  stores?: Store<any>[]
  [key: string]: any
}

const { id, stores = [], ...props } = Astro.props

if (stores) {
  stores.forEach(store => {
    hydrateServerStore(store, Astro.request)
  })
}

const dehydratedStores = dehydrateStores(stores)
const astroData = { data: dehydratedStores }
---
<script>
  import type { Store } from './src/stores/store'
  import { createClientStoreRegistry, getClientStoreRegistryStore } from './src/stores/clientStoreRegistry'
  import { dehydrateStores, hydrateClientStore } from './src/stores/hydration'
  import { fetchWithClientStoreData } from './src/session/temporary'

  createClientStoreRegistry()

  export class AstroFrame extends HTMLElement {
    public src: string = window.location.href
    public stores: Store[] = []
    private listeners: Function[] = []

    constructor() {
      super()
    }

    public connectedCallback() {
      const registry = getClientStoreRegistryStore()

      if (registry) {
        registry.listen(stores => {
          const myStores = this.getAttribute('stores')?.split(',') || []

          stores.forEach(store => {
            if (myStores.includes(store.name) && !this.stores.includes(store)) {
              hydrateClientStore(this, store)

              this.stores.push(store)
            }
          })
        })
      }

      this.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', async (e) => {
          if (form.method === "post") {
            e.preventDefault()
            e.stopImmediatePropagation()
            e.stopPropagation()

            const data = new FormData(form)
            const frame = form.closest('astro-frame') as AstroFrame

            if (!frame) return

            frame.reload(this.src, {
              method: "POST",
              body: JSON.stringify(Object.fromEntries(data))
            })
          }
        })
      })
    }

    // TODO: handle loading data from src
    static get observedAttributes() { return ['src']; }
    public attributeChangedCallback(name: string, oldValue: any, newValue: any) {

    }

    public async reload(src?: string, init: RequestInit = {}) {
      const dehydratedStores = dehydrateStores(this.stores)
      const url = src || this.src

      const response = await fetchWithClientStoreData(url, { data: dehydratedStores, output: "server" }, init)
      const page = await response.text()
      const parser = new DOMParser()
      const doc = parser.parseFromString(page, "text/html")
      const newFrame = doc.getElementById(this.id) as Node

      if (newFrame) {
        this.replaceWith(newFrame)
      }
    }

    public disconnectedCallback() {
      this.listeners.forEach((cb, i) => {
        cb()
      })
    }
  }

  customElements.define('astro-frame', AstroFrame)
</script>
<astro-frame id={id} stores={stores.map(store => store.name)} {...props}>
  <script type="application/json" set:html={JSON.stringify(astroData)} data-astro />
  <slot />
</astro-frame>
