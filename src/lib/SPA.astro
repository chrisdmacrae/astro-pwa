---
import { createRouter } from './routing/client';
import type { DehydratedRouter } from './routing/types';

export interface Props {
  router: DehydratedRouter
  [key: string]: any
}

const { router, ...props } = Astro.props

// This is a hack to have the router ready for SSR
createRouter(router)
---
<div id="__astro" {...props}>
  <script type="application/json" id="__astro-data" set:html={JSON.stringify(router)} />
  <script>
    import { createRouter, getDehydratedRouter, routerStore } from '../lib/routing/client'

    const dehydratedRouter = getDehydratedRouter()
    const hasRouter = Object.keys(routerStore.get()).keys.length !== 0
    
    if (dehydratedRouter && !hasRouter) {
      createRouter(dehydratedRouter)
    }
  </script>
  <script>(self.Astro=self.Astro||{}).load=a=>{(async()=>await(await a())())()},window.dispatchEvent(new Event("astro:load"));</script>
  <script>(self.Astro=self.Astro||{}).idle=t=>{const e=async()=>{await(await t())()};"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,200)},window.dispatchEvent(new Event("astro:idle"));</script>
  <script>(self.Astro=self.Astro||{}).visible=(s,c,n)=>{const r=async()=>{await(await s())()};let i=new IntersectionObserver(e=>{for(const t of e)if(!!t.isIntersecting){i.disconnect(),r();break}});for(let e=0;e<n.children.length;e++){const t=n.children[e];i.observe(t)}},window.dispatchEvent(new Event("astro:visible"));</script>
  <script>(self.Astro=self.Astro||{}).only=t=>{(async()=>await(await t())())()},window.dispatchEvent(new Event("astro:only"));</script>
  <script>(self.Astro=self.Astro||{}).media=(s,a)=>{const t=async()=>{await(await s())()};if(a.value){const e=matchMedia(a.value);e.matches?t():e.addEventListener("change",t,{once:!0})}},window.dispatchEvent(new Event("astro:media"));</script>
  <slot />
</div>